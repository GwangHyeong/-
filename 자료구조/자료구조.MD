## 자료구조

### O(Big-Oh) 표기법  
- EX) 8N^3+3N+5  --> O(N^3)

### (Theata)-표기법
~~~~~~
ex)
   s = 0  
   for I in range(N):
      for j in range(n):
            s += N
~~~~~~
답 : Theta(N)

### 스택(pop,push)
초기에 empty인 스택에서 push(1),push(2),pop(),push(1),push(2),pop(),pop(),pop(),push(2),pop() 연산을 차례로 수행할 경우 이 연산에서 pop연산이 출력한 결과는?  
답 : 2,2,1,1,2

 
### 후위표기법  
 (A-B)*C-D/(E+F)) 수식을 후위표기법으로 변환하시오 
 답 : AB-CxDEF+/-


### 스택  
* 스택은 한 쪽 끝에서만 항목을 삭제하거나 새로운 항목을 저장하는 자료구조이다.
* 웹 페이지를 이전으로 돌아가는 경우 등에사용
### 큐
* 삽입과 삭제가 양 끝에서 각각 수행되는 자료구조이다.
* 일상생활의 관공서,은행,우치국,병원 등에서 번호표를 이용한 줄서기가 대표적인 예시
### 데크
* 데크는 양쪽 끝에서 삽입과 삭제를 허용하는 자료구조이다.
* 데크는 스택과 큐 자료구조를 혼합한 자료구조라고 할 수 있다.

### 이진트리 중위순회
* 중위순회는 노드 n에 도착하면 n의 방문을 보류하고 n의 왼쪽 서브트리로 순회를 진행한다. 그리고 왼쪽 서브트리의 모든 노드들을 방문한 후에 n을 방문한다 n을 방문한 후에는 n의 오른쪽서브트리를 같은 방식으로 방문한다.
![캡처](https://user-images.githubusercontent.com/54932560/85943108-d042d680-b968-11ea-8706-6a3c1eea7cc3.PNG)  
중위순회 결과 : 2,17,7,19,3,100,25,36,1
후위순회 결과 : 2,7,17,3,19,25,1,36,100

### 이진트리 후위순회
* 후위순회는 노드 n에 도착하면 n의 방문을 보류하고 n의 왼쪽 서브트리로 순회를 진행한다. n의 왼쪽 서브트리를 방문한 후에는 n의 오른쪽 서브트리를 같은 방식으로 방문한다. 그리고 마지막에 n을 방문한다.
![캡처](https://user-images.githubusercontent.com/54932560/85943230-b48c0000-b969-11ea-947f-7ecbec1a660e.PNG)  
중위순회 결과 : A,B,C,D,E,F,G,H,I
후위순회 결과 : A,C,E,D,B,H,I,G,F  

### 최소힙 만들기
* 최소힙이란 키값이 작을수록 높은 우선순위를 가진힙
* 최소힙의 루트에는 항상 가장 작은 키가 저장된다.
* 최소힙의 노드에 저장된 키값이 자식노드의 키값보다 작다는 규칙을 따르기 때문이다.
3,9,15,12,13,8,1,4,7,2 순서로 리스트에 추가하고 최소힙을 생성하시오  
결과 1,2,3,4,9,9,15,12,7

### 최대힙 만들기
* 최대힙이란 키값이 높을수록 높은 우선순위를 가진힙
* 최대힙의 루트에는 항상 가장 큰 키가 저장된다. 
43,37,18,25,26,59,53,63 을 가지고 최대힙을 생성하시오  
결과 63,43,59,37,26,18,53,25

### 이진탐색트리
* 이진탐색트리는 이진탐색의 개념을 트리 형태의 구조에 접목시킨 자료구조이다.
* 이진탐색이란 1차원 리스트에 데이터가 정렬되어 있을 때, 주어진 데이터를 효율적으로 찾는 알고리즘이다.
3,9,15,12,13,8,1,4,7,2 순서로 이진탐색트리를 생성하시오.
images.githubusercontent.com/54932560/85943795-56611c00-b96d-11ea-9f64-4e6b7f5ea216.jpg)

### 해시
* 선형조사
  * 충돌이 일어난 원소에서부터 순차적으로 검색하여 처음 발견한 empty원소에 충돌이 일어난 키를 저장한다.
  * 충돌이 나면 바로 다음 원소를 검사
* 이차조사
  * 선형조사와 근본적으로 동일한 충돌 해결 방법이다.
  * 충돌 후 1차원 리스트 a에서 j^2으로 보다 더 멀리 떨어진 곳에서 empty 원소를 찾는다(1^2,2^2,3^3 ...)
  * 충돌이 나면 갈수록 더 멀리 떨어진 원소를 검사하자
* 랜덤조사
  * 선형조사와 이차조사의 규칙점인 점프 시퀀스와는 달리 점프 시퀀스를 무작위화하여 empty원소를 찾는 충돌 해결 방법
  * 충돌이 나면 일정한 규칙 없이 비어 있는 원소를 검사하자
* 이중해싱
  * 2개의 해시함수를 사용하는 충돌 해결 방법이다.
  * 충돌이 나면 다른 해시함수의 해시값을 이용하여 원소를 검사하자.
* 폐쇄주소방식
  * 키에 대한 해시값에 대응되는 곳에만 키를 저장한다.
  * 따라서 충돌이 발생한 키들은 한 위치에 모아 저장된다(키체인)
  
 
  ### 선택정렬
  * 리스트에서 아직 정렬 안된 부분의 원소들 중에서 최솟값을 '선택'하여 정렬 안된 부분의 가장 왼쪽의 원소와 교환하는 정렬 알고리즘이다.
  43,37,18,25,26,59,53,63 다음 수의 선택정렬 결과는?
  1회전 결과 : 18 37 43 25 26 59 53 63  
  2회전 결과 : 18 25 43 37 26 59 53 63
  3회전 결과 : 18 25 26 37 43 59 53 63
  4회전 결과 : 18 25 26 37 43 53 59 63  
  
  ### 삽입정렬
  * 리스트가 정렬된 부분과 정렬 안된 부분으로 나뉘며, 정렬 안된 부분의 가장 왼쪽 언소를 정렬된 부분에 삽입하는 방식의 정렬 알고리즘이다.
  43,37,18,25,26,59,53,63 다음 수의 삽입정렬 결과는?
  1회전 결과 : 37 43 18 25 26 59 53 63
  2회전 결과 : 18 37 43 25 26 59 53 63
  3회전 결과 : 18 25 37 43 26 59 53 63
  4회전 결과 : 18 25 26 37 43 59 53 63
  5회전 결과 : 18 25 26 37 43 53 59 63
  
  ### 힙정렬
  * 최대힙을 이용하여 루트를 힙의 가장 마지막 노드와 교환한 후 힙 크기를 1감소시키고, 루트로부터 downheap 연산으로 힙 속성을 복원하는 과정을 반복하여 정렬한다.
  * 먼저 리스트에 저장된 데이터의 키를 우선순위로 하는 최대힙을 만든다.
  * 이 후 루트의 숫자를 힙의 가장 마지막 노드에 있는 숫자와 교환한 후 힙 크기를 1감소시키고, 루트로 이동한 숫자로 인해 위배된 힙속성을 4.4절에서 설명한 다운힙 연산으로 복원한다.
  
  ### 퀵정렬
  * 퀵정렬은 입력의 맨 왼쪽 원소를 기준으로 피벗보다 작은 원소들과 큰 원소들을 각각 피벗의 좌우로 분할한 후, 피벗보다 작은 부분과 피벗보다 큰 부분을 각각 재귀적으로 정렬하는 알고리즘이다.
  * 단 동일한 키가 없어야함
  43,37,18,25,26,59,53,63 다음 수의 퀵정렬 결과는?
  1회전 결과 : 26,37,18,25,43,59,53,63
  2회전 결과 : 18,37,26,25,43,59,53,63
  3회전 결과 : 18,25,26,37,43,53,59,63
  
 
